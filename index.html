<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Relate — Local Prototype</title>
<style>
  :root{
    --bg:#1a0033; --card:#2b0046; --accent:#9b6bff; --muted:#c9b6ff; --white:#ffffff;
    --blue:#70c6ff; --green:#6ee07a; --yellow:#ffd24d; --pink:#ff90d0; --red:#ff6b6b; --whiteRel:#ffffff;
  }
  html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--white)}
  .wrap{display:flex;gap:18px;padding:18px;box-sizing:border-box;height:100%}
  .sidebar{width:320px;background:linear-gradient(180deg,#250033,#22002d);border-radius:12px;padding:12px;box-sizing:border-box;overflow:auto}
  h1{margin:4px 0;color:var(--accent)}
  label{display:block;margin-top:10px;font-size:13px;color:var(--muted)}
  input[type="text"], select, textarea {width:100%;padding:10px;border-radius:8px;border:none;margin-top:6px;background:#fff;color:#111;box-sizing:border-box}
  button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  .usersList{margin-top:12px;max-height:46vh;overflow:auto}
  .userRow{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;margin-bottom:8px;background:rgba(255,255,255,0.03)}
  .small{font-size:12px;color:var(--muted)}
  .main{flex:1;display:flex;flex-direction:column}
  .mapCard{flex:1;background:linear-gradient(180deg,#170022,#0f0018);border-radius:12px;padding:12px;display:flex;flex-direction:column;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
  .mapArea{flex:1;display:flex;align-items:center;justify-content:center;position:relative}
  svg{width:100%;height:100%}
  .tooltip{position:absolute;pointer-events:none;background:linear-gradient(180deg,#3b0064,#6200b0);padding:8px;border-radius:8px;color:#fff;font-size:13px;transform:translate(-50%,-120%);white-space:nowrap;box-shadow:0 4px 12px rgba(0,0,0,0.6)}
  .profile{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);min-width:320px;background:var(--card);border-radius:12px;padding:16px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  .relSelect{width:100%;padding:8px;border-radius:8px;border:none;margin-top:8px}
  .infoSmall{font-size:13px;color:var(--muted)}
  .requestsBox{background:#fff;color:#111;padding:10px;border-radius:8px;margin-top:8px;max-height:220px;overflow:auto}
  .requestItem{display:flex;justify-content:space-between;align-items:center;padding:6px;border-radius:6px;background:#f6f3ff;margin-bottom:6px}
  .chatBox{background:#fff;color:#111;padding:10px;border-radius:8px;margin-top:8px}
  .chatMessages{height:140px;overflow:auto;background:#eee;padding:8px;border-radius:6px}
  .msg{padding:6px;margin:6px;border-radius:8px;display:inline-block}
  .msg.you{background:#dfeaff;align-self:flex-end}
  .msg.them{background:#ffeef2}
  .tick{color:#6ee07a;font-weight:900;margin-left:6px}
  .smallMuted{font-size:12px;color:#bdb0ff}
  .actionSmall{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 8px;border-radius:6px;color:var(--muted);cursor:pointer}
</style>
</head>
<body>
<div class="wrap">
  <div class="sidebar">
    <h1>Relate (local)</h1>

    <div id="entry">
      <label>Name</label>
      <input id="nameInput" placeholder="Your name (e.g. Nisa)">
      <label>Class</label>
      <select id="classSelect"><option value="">Select class</option></select>
      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="enterBtn">Enter</button>
        <button id="logoutBtn" style="display:none;background:#444">Logout</button>
      </div>
      <div style="margin-top:8px" class="smallMuted">Logged in as: <span id="logged">—</span></div>
    </div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,0.04);margin:12px 0">

    <div style="display:flex;justify-content:space-between;align-items:center">
      <div class="small">People</div>
      <div class="smallMuted">Requests: <span id="pendingCount">0</span></div>
    </div>
    <div class="usersList" id="usersList"></div>

    <div style="margin-top:12px">
      <div class="small" style="margin-bottom:6px">Export / Import state (manual sync)</div>
      <textarea id="stateArea" rows="4" style="width:100%;"></textarea>
      <div style="display:flex;gap:8px;margin-top:6px">
        <button id="exportBtn">Copy state</button>
        <button id="importBtn" style="background:#444">Paste state</button>
        <button id="refreshBtn" style="background:#333">Refresh</button>
      </div>
      <div class="smallMuted" style="margin-top:8px">Use copy/paste between browsers to simulate multi-user.</div>
    </div>
  </div>

  <div class="main">
    <div class="mapCard">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
        <div class="infoSmall">Map — center is you. Hover for quick info. Click for profile.</div>
        <div><button id="showRequestsBtn" class="actionSmall">Show requests</button></div>
      </div>

      <div class="mapArea" id="mapArea">
        <svg id="svgMap" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet"></svg>
        <div id="tooltip" class="tooltip" style="display:none"></div>
        <div id="profileDiv" class="profile" style="display:none"></div>
      </div>

      <div style="margin-top:10px;color:var(--muted);font-size:13px">Quick chat phrases: <button class="actionSmall" data-phrase="Hi">Hi</button> <button class="actionSmall" data-phrase="Bye">Bye</button> <button class="actionSmall" data-phrase="BRB">BRB</button> <button class="actionSmall" data-phrase="Call">Call</button></div>
    </div>
  </div>
</div>

<script>
/* -----------------------
  Local Relate Prototype
  All data stored under localStorage key 'relate_state'
------------------------*/

const RELATE_KEY = 'relate_state_v1';

// init UI refs
const nameInput = document.getElementById('nameInput');
const classSelect = document.getElementById('classSelect');
const enterBtn = document.getElementById('enterBtn');
const logoutBtn = document.getElementById('logoutBtn');
const usersList = document.getElementById('usersList');
const logged = document.getElementById('logged');
const pendingCount = document.getElementById('pendingCount');
const svgMap = document.getElementById('svgMap');
const tooltip = document.getElementById('tooltip');
const profileDiv = document.getElementById('profileDiv');
const stateArea = document.getElementById('stateArea');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const refreshBtn = document.getElementById('refreshBtn');
const showRequestsBtn = document.getElementById('showRequestsBtn');

// populate classes 1..12
for(let i=1;i<=12;i++){
  const o = document.createElement('option'); o.value = i; o.textContent = `Class ${i}`; classSelect.appendChild(o);
}

/* --------- State model (localStorage) ----------
state = {
  users: [{ name, class }],
  requests: [{ from, to, time }],   // pending only
  connections: [{ id, userA, userB, typeA, typeB, lastChangedA, lastChangedB }], // relation doc; typeX null or a string
  notifications: [{ to, text, time, seen }],
  messages: [{ chatId, from, to, text, time }]
}
-------------------------------------------------*/

function loadState(){
  const raw = localStorage.getItem(RELATE_KEY);
  if(!raw) {
    const base = { users: [], requests: [], connections: [], notifications: [], messages: [] };
    localStorage.setItem(RELATE_KEY, JSON.stringify(base));
    return base;
  }
  try { return JSON.parse(raw); } catch(e){ console.error('bad state'); return { users:[],requests:[],connections:[],notifications:[],messages:[] }; }
}
function saveState(s){ localStorage.setItem(RELATE_KEY, JSON.stringify(s)); }

let state = loadState();

// currentUser {name,class} or null
let currentUser = JSON.parse(localStorage.getItem('relate_current')) || null;

/* ---------- Helpers ---------- */
function findUserByName(name){ return state.users.find(u=>u.name.toLowerCase()===name.toLowerCase()); }
function connectionId(a,b){ return [a.trim().toLowerCase(), b.trim().toLowerCase()].sort().join('__'); }
function addNotification(to, text){
  state.notifications.push({ to, text, time: Date.now(), seen:false });
  saveState(state);
}
function messagesChatId(a,b){ return [a.trim().toLowerCase(), b.trim().toLowerCase()].sort().join('__'); }

/* ---------- UI rendering ---------- */

function renderUsersList(){
  usersList.innerHTML='';
  const others = state.users.filter(u => !currentUser || u.name.toLowerCase() !== currentUser.name.toLowerCase());
  others.sort((a,b)=>a.name.localeCompare(b.name));
  others.forEach(u=>{
    const row = document.createElement('div'); row.className='userRow';
    const left = document.createElement('div'); left.innerHTML = `<div style="font-weight:700">${u.name}</div><div class="small">Class ${u.class||'–'}</div>`;
    const right = document.createElement('div');
    // show tick if request sent or connected
    const sent = state.requests.some(r => r.from.toLowerCase()=== (currentUser?currentUser.name.toLowerCase():'') && r.to.toLowerCase()===u.name.toLowerCase());
    const connected = state.connections.some(c => (c.userA.toLowerCase()===u.name.toLowerCase() && c.userB.toLowerCase()=== (currentUser?currentUser.name.toLowerCase():'')) || (c.userB.toLowerCase()===u.name.toLowerCase() && c.userA.toLowerCase()=== (currentUser?currentUser.name.toLowerCase():'')));
    const addBtn = document.createElement('button'); addBtn.textContent = sent || connected ? (connected? '✓':'Sent') : '+';
    addBtn.title = connected ? 'Connected' : (sent ? 'Request sent' : 'Send request');
    addBtn.disabled = sent || connected || !currentUser;
    addBtn.onclick = async ()=>{
      // send request
      state.requests.push({ from: currentUser.name, to: u.name, time: Date.now() });
      saveState(state);
      renderUsersList();
      await updatePendingCount();
      alert(`✅ Friend request sent to ${u.name}`);
    };
    right.appendChild(addBtn);
    row.appendChild(left); row.appendChild(right);
    usersList.appendChild(row);
  });
}

async function updatePendingCount(){
  if(!currentUser){ pendingCount.textContent='0'; return; }
  const count = state.requests.filter(r => r.to.toLowerCase()===currentUser.name.toLowerCase()).length;
  pendingCount.textContent = String(count);
}

function renderMap(){
  svgMap.innerHTML = '';
  tooltip.style.display='none';
  profileDiv.style.display='none';
  if(!currentUser) return;
  // Build nodes: center is currentUser, friends around + mutuals that connect through them
  const center = { name: currentUser.name, x:500, y:350, r:26, isCenter:true };
  // who are connections (connected but not necessarily relation set)
  const direct = [];
  state.connections.forEach(c=>{
    const a = c.userA, b = c.userB;
    if(a.toLowerCase()===currentUser.name.toLowerCase()) direct.push(b);
    else if(b.toLowerCase()===currentUser.name.toLowerCase()) direct.push(a);
  });
  // unique
  const friendNames = Array.from(new Set(direct));
  // pick positions – use deterministic angle from name hash for stable layout
  const nodes = [center];
  const count = friendNames.length;
  const radius = Math.min(260, 100 + count * 26);
  friendNames.forEach((nm,i)=>{
    // deterministic angle
    const hash = Array.from(nm).reduce((s,ch)=>s+ch.charCodeAt(0),0);
    const angle = (hash % 360) * Math.PI / 180 + (i*0.5);
    const x = 500 + radius * Math.cos(angle);
    const y = 350 + radius * Math.sin(angle);
    nodes.push({ name: nm, x, y, r:20, isCenter:false });
  });
  // Also include mutual connections among those friends (connections between them) so that lines show
  // But only include nodes that are already present or are connected to present nodes
  const presentNames = nodes.map(n=>n.name.toLowerCase());
  // ensure all connections between friend nodes are considered when drawing lines
  // Draw lines first
  state.connections.forEach(c=>{
    const a = c.userA, b = c.userB;
    const idxA = nodes.findIndex(n=>n.name.toLowerCase()===a.toLowerCase());
    const idxB = nodes.findIndex(n=>n.name.toLowerCase()===b.toLowerCase());
    if(idxA===-1 || idxB===-1) return;
    const nA = nodes[idxA], nB = nodes[idxB];
    // determine state: check types
    const tA = c.typeA || null, tB = c.typeB || null;
    // display rules:
    // - if neither chosen: no line (we decided earlier default no line) BUT you asked for dashed when one chooses, grey when mismatch. When both none, no line.
    // - if only one chosen => dashed
    // - if both chosen and equal => color
    // - if both chosen and different => grey
    let draw = false, dashed=false, color = null;
    if(tA && !tB){ draw = true; dashed = true; color = 'line-dashed'; }
    else if(!tA && tB){ draw = true; dashed = true; color = 'line-dashed'; }
    else if(tA && tB){
      draw = true;
      if(tA === tB){ color = relationColor(tA); dashed=false; }
      else { color = 'grey'; dashed=false; }
    } else { draw=false; }
    if(!draw) return;
    const ns = document.createElementNS('http://www.w3.org/2000/svg','line');
    ns.setAttribute('x1', nA.x); ns.setAttribute('y1', nA.y);
    ns.setAttribute('x2', nB.x); ns.setAttribute('y2', nB.y);
    ns.setAttribute('stroke-width', 3);
    if(dashed){
      ns.setAttribute('stroke-dasharray','8 6');
      ns.setAttribute('stroke','#9b9b9b');
    } else {
      if(color==='grey') ns.setAttribute('stroke','#9b9b9b');
      else ns.setAttribute('stroke', color);
    }
    svgMap.appendChild(ns);
  });

  // draw nodes
  nodes.forEach(node=>{
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform', `translate(${node.x},${node.y})`);
    g.setAttribute('data-name', node.name);
    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('r', node.r);
    circle.setAttribute('fill', node.isCenter ? '#cfa0ff' : '#70c6ff');
    circle.setAttribute('stroke','#fff'); circle.setAttribute('stroke-width', node.isCenter?2:1);
    circle.style.cursor = 'pointer';
    g.appendChild(circle);
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('y', node.isCenter ? 6 : 4);
    t.setAttribute('text-anchor','middle');
    t.setAttribute('font-size', node.isCenter?14:11);
    t.setAttribute('fill','#111');
    t.textContent = node.name;
    g.appendChild(t);

    // hover
    g.addEventListener('mouseenter', (ev)=>{
      const nm = node.name;
      const user = findUserByName(nm) || {};
      const rel = myRelationTo(nm);
      tooltip.style.display='block';
      tooltip.innerHTML = `<strong>${nm}</strong> &middot; Class ${user.class||'–'}<br><span class="small">${rel?('You set: '+rel):'Relation not set'}</span>`;
      positionTooltip(ev);
    });
    g.addEventListener('mousemove', positionTooltip);
    g.addEventListener('mouseleave', ()=> tooltip.style.display='none');

    // click -> profile
    g.addEventListener('click', ()=> openProfile(node.name));

    svgMap.appendChild(g);
  });

  function positionTooltip(ev){
    const rect = document.getElementById('mapArea').getBoundingClientRect();
    tooltip.style.left = (ev.clientX - rect.left) + 'px';
    tooltip.style.top = (ev.clientY - rect.top - 12) + 'px';
  }
}

/* ---- relation color map ---- */
function relationColor(type){
  if(!type) return '#9b9b9b';
  const t = type.toLowerCase();
  if(t==='friends' || t==='friend') return getComputedStyle(document.documentElement).getPropertyValue('--blue').trim() || '#70c6ff';
  if(t==='close friends' || t==='close') return getComputedStyle(document.documentElement).getPropertyValue('--green').trim() || '#6ee07a';
  if(t==='best friends' || t==='best') return getComputedStyle(document.documentElement).getPropertyValue('--yellow').trim() || '#ffd24d';
  if(t==='crush') return getComputedStyle(document.documentElement).getPropertyValue('--pink').trim() || '#ff90d0';
  if(t==='hate' || t==='enemies') return getComputedStyle(document.documentElement).getPropertyValue('--red').trim() || '#ff6b6b';
  if(t==='classmate') return getComputedStyle(document.documentElement).getPropertyValue('--whiteRel').trim() || '#ffffff';
  return '#9b9b9b';
}

/* ---------- Profile overlay & actions ---------- */
function openProfile(name){
  profileDiv.style.display='block';
  profileDiv.innerHTML = '';
  profileDiv.style.minWidth='320px';
  const user = findUserByName(name) || {class:'–'};
  const title = document.createElement('div'); title.innerHTML = `<h3 style="margin:0">${name}</h3>`;
  const info = document.createElement('div'); info.className='infoSmall'; info.innerHTML = `Class ${user.class||'–'}`;
  profileDiv.appendChild(title); profileDiv.appendChild(info);

  // show friend count
  const fc = document.createElement('div'); fc.className='infoSmall'; fc.style.marginTop='8px';
  fc.textContent = `Connections: ${computeConnectionCount(name)}`;
  profileDiv.appendChild(fc);

  // relation control (if currentUser exists and not the same)
  if(currentUser && currentUser.name.toLowerCase() !== name.toLowerCase()){
    const relLabel = document.createElement('div'); relLabel.style.marginTop='10px'; relLabel.textContent = 'Set your relation to this person (one change / 7 days):';
    const sel = document.createElement('select'); sel.className='relSelect';
    ['', 'Friends','Close Friends','Best Friends','Crush','Hate','Classmate'].forEach(v=>{
      const o=document.createElement('option'); o.value=v; o.textContent = v?v:'Select relation'; sel.appendChild(o);
    });
    // preselect if currentUser already set
    const existing = getMyRelationTo(name);
    if(existing) sel.value = existing;
    profileDiv.appendChild(relLabel); profileDiv.appendChild(sel);

    const saveBtn = document.createElement('button'); saveBtn.textContent = 'Save relation'; saveBtn.style.marginTop='8px';
    saveBtn.onclick = ()=>{
      const chosen = sel.value;
      if(!chosen){ alert('Choose relation'); return; }
      // enforce one-change-per-7-days
      const connId = connectionId(currentUser.name, name);
      const conn = state.connections.find(c=>c.id===connId);
      const now = Date.now();
      if(conn){
        // determine who is A/B
        const isA = (conn.userA.toLowerCase() === currentUser.name.toLowerCase());
        const last = isA ? conn.lastChangedA : conn.lastChangedB;
        if(last && (now - last) < 7*24*3600*1000){
          alert('You can change relation only once per 7 days.');
          return;
        }
      } else {
        alert('You must accept connection first.');
        return;
      }
      // set relation
      if(conn){
        if(conn.userA.toLowerCase()===currentUser.name.toLowerCase()){
          conn.typeA = chosen;
          conn.lastChangedA = now;
        } else {
          conn.typeB = chosen;
          conn.lastChangedB = now;
        }
        saveState(state);
        // notify other user that someone updated their connection status
        const other = (conn.userA.toLowerCase()===currentUser.name.toLowerCase()) ? conn.userB : conn.userA;
        addNotification(other, `${currentUser.name} updated your connection status — choose your view.`);
        renderUsersList(); renderMap(); renderNotifications();
        alert('Relation saved.');
      }
    };
    profileDiv.appendChild(saveBtn);
  } else {
    const selfNote = document.createElement('div'); selfNote.className='infoSmall'; selfNote.style.marginTop='12px'; selfNote.textContent = 'This is you.';
    profileDiv.appendChild(selfNote);
  }

  // Chat area if connected
  if(currentUser && areConnected(currentUser.name, name)){
    const chatWrap = document.createElement('div'); chatWrap.className='chatBox'; chatWrap.style.marginTop='12px';
    chatWrap.innerHTML = `<div style="font-weight:700">Chat with ${name}</div><div id="chatMessages" class="chatMessages"></div>`;
    const inpt = document.createElement('input'); inpt.placeholder='Type a message';
    const sendBtn = document.createElement('button'); sendBtn.textContent='Send'; sendBtn.style.marginLeft='6px';
    sendBtn.onclick = ()=> {
      const text = inpt.value.trim();
      if(!text) return;
      const chatId = messagesChatId(currentUser.name, name);
      state.messages.push({ chatId, from: currentUser.name, to: name, text, time: Date.now() });
      saveState(state); inpt.value=''; renderChatMessages(chatId);
    };
    chatWrap.appendChild(inpt); chatWrap.appendChild(sendBtn);
    profileDiv.appendChild(chatWrap);
    renderChatMessages(messagesChatId(currentUser.name, name));
    // quick phrases
    document.querySelectorAll('.actionSmall[data-phrase]').forEach(b=>{
      b.onclick = ()=> {
        const p = b.getAttribute('data-phrase');
        state.messages.push({ chatId: messagesChatId(currentUser.name, name), from: currentUser.name, to: name, text: p, time: Date.now() });
        saveState(state); renderChatMessages(messagesChatId(currentUser.name, name));
      };
    });
  }

  const close = document.createElement('button'); close.textContent='Close'; close.style.marginTop='12px'; close.style.marginLeft='8px';
  close.onclick = ()=> { profileDiv.style.display='none'; };
  profileDiv.appendChild(close);
}

function renderChatMessages(chatId){
  const wrap = document.getElementById('chatMessages');
  if(!wrap) return;
  wrap.innerHTML = '';
  const msgs = state.messages.filter(m=>m.chatId===chatId).sort((a,b)=>a.time-b.time);
  msgs.forEach(m=>{
    const div = document.createElement('div'); div.className = 'msg ' + (m.from.toLowerCase()===currentUser.name.toLowerCase() ? 'you':'them');
    div.textContent = `${m.from}: ${m.text}`;
    wrap.appendChild(div);
  });
}

/* ---------- Requests UI ---------- */
function showRequestsPanel(){
  // build panel in tooltip area (temporary)
  const panel = document.createElement('div'); panel.className='requestsBox';
  panel.innerHTML = '<strong>Incoming Requests</strong>';
  const incoming = state.requests.filter(r => currentUser && r.to.toLowerCase() === currentUser.name.toLowerCase());
  if(incoming.length===0) panel.innerHTML += '<div class="smallMuted">No pending requests</div>';
  incoming.forEach(req=>{
    const ri = document.createElement('div'); ri.className='requestItem';
    const left = document.createElement('div'); left.innerHTML = `<div style="font-weight:700">${req.from}</div><div class="small">sent ${new Date(req.time).toLocaleString()}</div>`;
    const right = document.createElement('div');
    const acc = document.createElement('button'); acc.textContent='Accept'; acc.onclick = ()=>{
      acceptRequest(req);
      document.body.removeChild(panelWrap);
    };
    const dec = document.createElement('button'); dec.textContent='Decline'; dec.style.marginLeft='6px'; dec.onclick = ()=>{ declineRequest(req); document.body.removeChild(panelWrap); };
    right.appendChild(acc); right.appendChild(dec);
    ri.appendChild(left); ri.appendChild(right);
    panel.appendChild(ri);
  });
  // overlay panel
  const panelWrap = document.createElement('div');
  panelWrap.style.position='fixed'; panelWrap.style.right='20px'; panelWrap.style.top='70px'; panelWrap.style.zIndex=9999;
  panelWrap.appendChild(panel);
  document.body.appendChild(panelWrap);
}

/* ---------- Request handling ---------- */
function acceptRequest(req){
  // add connection doc (deterministic id)
  const id = connectionId(req.from, req.to);
  const exist = state.connections.find(c=>c.id===id);
  if(!exist){
    state.connections.push({ id, userA: req.from, userB: req.to, typeA: null, typeB: null, lastChangedA:null, lastChangedB:null });
  }
  // remove request
  state.requests = state.requests.filter(r => !(r.from===req.from && r.to===req.to));
  // send notification to requester
  addNotification(req.from, `${req.to} accepted your connection.`);
  saveState(state); renderUsersList(); updatePendingCount(); renderMap();
}

function declineRequest(req){
  // remove request and remove sent tick for sender (tick is derived from requests so will disappear)
  state.requests = state.requests.filter(r => !(r.from===req.from && r.to===req.to));
  saveState(state); renderUsersList(); updatePendingCount(); renderMap();
}

/* ---------- connections helpers ---------- */
function computeConnectionCount(name){
  let count=0;
  state.connections.forEach(c=>{
    if(c.userA.toLowerCase()===name.toLowerCase() || c.userB.toLowerCase()===name.toLowerCase()){
      count++;
    }
  });
  return count;
}

function areConnected(a,b){
  const id = connectionId(a,b);
  return state.connections.some(c=>c.id===id);
}

function getMyRelationTo(other){
  const id = connectionId(currentUser.name, other);
  const conn = state.connections.find(c=>c.id===id);
  if(!conn) return null;
  if(conn.userA.toLowerCase()===currentUser.name.toLowerCase()) return conn.typeA || null;
  return conn.typeB || null;
}

function myRelationTo(other){
  if(!currentUser) return null;
  return getMyRelationTo(other);
}

/* ---------- Notifications ---------- */
function renderNotifications(){
  // small badge already handled by pending count
  // Optionally add a UI to view notifications - not required for now
}

/* ---------- Export / Import ---------- */
exportBtn.onclick = ()=>{
  const t = JSON.stringify(state);
  navigator.clipboard && navigator.clipboard.writeText(t).then(()=>alert('State copied. Paste into other browser with "Paste state".'));
};
importBtn.onclick = ()=>{
  try{
    const txt = stateArea.value.trim();
    if(!txt) return alert('Paste exported state into the textarea first.');
    const incoming = JSON.parse(txt);
    // merge: simple replace (overwrite)
    state = incoming;
    saveState(state);
    alert('State imported. Click Refresh to reload UI.');
  }catch(e){ alert('Bad JSON'); }
};
refreshBtn.onclick = ()=>{
  state = loadState();
  currentUser = JSON.parse(localStorage.getItem('relate_current')) || null;
  updateUIAfterRefresh();
};

/* ---------- Accept/Decline helpers for external test ---------- */
async function updateUIAfterRefresh(){
  renderUsersList();
  await updatePendingCount();
  renderMap();
  if(currentUser){ logged.textContent = `${currentUser.name} (Class ${currentUser.class})`; logoutBtn.style.display='inline-block'; }
  else { logged.textContent='—'; logoutBtn.style.display='none'; }
}

/* ---------- Accept Request invoked via notification buttons ---------- */
function connectionId(a,b){
  return [a.trim().toLowerCase(), b.trim().toLowerCase()].sort().join('__');
}

/* ---------- Messages quick phrase buttons ---------- */
document.querySelectorAll('.actionSmall[data-phrase]').forEach(b=>{
  b.addEventListener('click', ()=>{
    // if profile overlay open and chat present, send; else no-op
    const pd = profileDiv.style.display;
    if(pd!=='block') return alert('Open a profile (click a connected user) to send quick phrase.');
    const chatInput = profileDiv.querySelector('input');
    const nameTitle = profileDiv.querySelector('h3').textContent;
    if(!chatInput || !currentUser) return;
    const phrase = b.getAttribute('data-phrase');
    const chatId = messagesChatId(currentUser.name, nameTitle);
    state.messages.push({ chatId, from: currentUser.name, to: nameTitle, text: phrase, time: Date.now() });
    saveState(state);
    renderChatMessages(chatId);
  });
});

/* ---------- Enter / Logout ---------- */
enterBtn.onclick = async ()=>{
  const name = nameInput.value.trim();
  const klass = classSelect.value;
  if(!name || !klass) return alert('Enter name and class');
  // add user if needed
  if(!findUserByName(name)){
    state.users.push({ name, class: klass });
    saveState(state);
  } else {
    // update class if changed
    const u = findUserByName(name);
    if(u.class !== klass){ u.class = klass; saveState(state); }
  }
  currentUser = { name, class: klass };
  localStorage.setItem('relate_current', JSON.stringify(currentUser));
  updateUIAfterRefresh();
  renderNotifications();
  alert('Welcome ' + name);
};

logoutBtn.onclick = ()=>{ localStorage.removeItem('relate_current'); currentUser = null; updateUIAfterRefresh(); };

/* ---------- Show requests button ---------- */
showRequestsBtn.onclick = ()=> showRequestsPanel();

/* ---------- Initial render ---------- */
updateUIAfterRefresh();

</script>
</body>
</html>



