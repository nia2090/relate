<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Relate — Map & Connections</title>
<link rel="icon" href="data:," />
<style>
  :root{
    --bg:#120018; --card:#1f0630; --accent:#9b6bff; --muted:#cdb8ff; --white:#ffffff;
    --blue:#70c6ff; --green:#6ee07a; --yellow:#ffd24d; --pink:#ff90d0; --red:#ff6b6b; --whiteRel:#ffffff;
  }
  html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--white)}
  .container{display:flex;gap:18px;padding:18px;box-sizing:border-box;height:100%}
  .sidebar{width:320px;background:linear-gradient(180deg,#22002d,#1a0023);border-radius:12px;padding:16px;box-shadow:0 8px 30px rgba(0,0,0,0.6);overflow:auto}
  h1{margin:4px 0;color:var(--accent)}
  label{display:block;margin-top:10px;font-size:13px;color:var(--muted)}
  input[type="text"], input[type="password"], select, textarea {width:100%;padding:10px;border-radius:8px;border:none;margin-top:6px;background:#fff;color:#111;box-sizing:border-box}
  button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  .usersList{margin-top:12px;max-height:40vh;overflow:auto}
  .userRow{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;margin-bottom:8px;background:rgba(255,255,255,0.03)}
  .small{font-size:12px;color:var(--muted)}
  .main{flex:1;display:flex;flex-direction:column}
  .card{background:linear-gradient(180deg,#170022,#0f0018);border-radius:12px;padding:12px;display:flex;flex-direction:column;box-shadow:0 6px 20px rgba(0,0,0,0.6);height:100%}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  .mapArea{flex:1;display:flex;align-items:center;justify-content:center;position:relative;border-radius:8px;overflow:hidden}
  svg{width:100%;height:100%}
  .tooltip{position:absolute;pointer-events:none;background:linear-gradient(180deg,#3b0064,#6200b0);padding:8px;border-radius:8px;color:#fff;font-size:13px;transform:translate(-50%,-120%);white-space:nowrap;box-shadow:0 4px 12px rgba(0,0,0,0.6)}
  .overlay{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);min-width:320px;background:var(--card);border-radius:12px;padding:16px;box-shadow:0 8px 30px rgba(0,0,0,0.6);z-index:999}
  .relSelect{width:100%;padding:8px;border-radius:8px;border:none;margin-top:8px}
  .smallMuted{font-size:12px;color:var(--muted)}
  .requestsBox{background:#fff;color:#111;padding:10px;border-radius:8px;margin-top:8px;max-height:240px;overflow:auto}
  .requestItem{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:#f6f3ff;margin-bottom:8px}
  .friendsList{margin-top:12px}
  .friendItem{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;margin-bottom:6px}
  .tabRow{display:flex;gap:8px;margin-bottom:8px}
  .tabRow button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px 10px;border-radius:8px}
  .activeTab{background:var(--accent);color:#fff;border:none}
  .badge{background:rgba(155,107,255,0.18);padding:6px 10px;border-radius:999px;color:var(--muted);font-weight:600}
  .quickPhrases{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .quickPhrases button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 8px;border-radius:6px;color:var(--muted)}
  .muted{color:var(--muted);font-size:13px}
  .node-center{fill:#cfa0ff;stroke:#fff;stroke-width:2}
  .node-conn{fill:#70c6ff;stroke:#fff;stroke-width:1}
</style>
</head>
<body>
<div class="container">
  <!-- SIDEBAR -->
  <div class="sidebar">
    <h1>Relate</h1>

    <!-- Login -->
    <div id="loginPanel">
      <label>Name</label>
      <input id="loginName" placeholder="Your name (e.g. Nisa)" />
      <label>Password</label>
      <input id="loginPass" type="password" placeholder="Choose a password / enter to login" />
      <label>Class</label>
      <select id="loginClass"><option value="">Select class</option></select>
      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="btnEnter">Enter</button>
        <button id="btnLogout" style="display:none;background:#444">Logout</button>
      </div>
      <div style="margin-top:8px" class="smallMuted">Logged in as: <span id="who">—</span></div>
    </div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,0.04);margin:12px 0">

    <!-- Tabs -->
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div class="small">People</div>
      <div><span class="badge" id="reqBadge">0</span></div>
    </div>

    <!-- Users list -->
    <div class="usersList" id="usersList"></div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,0.04);margin:12px 0">

    <!-- Suggestions -->
    <div>
      <div style="display:flex;justify-content:space-between;align-items:center"><div class="small">You Might Know</div><div class="smallMuted">auto</div></div>
      <div id="suggestions" style="margin-top:8px"></div>
    </div>

  </div>

  <!-- MAIN -->
  <div class="main">
    <div class="card">
      <div class="topbar">
        <div>
          <div class="tabRow" role="tablist">
            <button id="tabRequests">Requests</button>
            <button id="tabMessages">Messages</button>
            <button id="tabMap" class="activeTab">Map</button>
            <button id="tabSearch">Search</button>
            <button id="tabConnections">Connections</button>
          </div>
          <div class="muted" id="subInfo">Hover nodes for info — click to open profile</div>
        </div>
        <div>
          <button id="btnRefresh" style="background:#321a4d">Refresh</button>
        </div>
      </div>

      <!-- CONTENT AREAS -->
      <div id="contentRequests" style="display:none">
        <div class="requestsBox" id="requestsBox"></div>
      </div>

      <div id="contentMessages" style="display:none">
        <div><strong>Quick messages</strong></div>
        <div class="quickPhrases" id="quickPhrases"></div>
        <div style="margin-top:12px"><strong>Active chat</strong></div>
        <div id="chatArea"></div>
      </div>

      <div id="contentMap" class="mapArea">
        <svg id="mapSvg" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet"></svg>
        <div id="tooltip" class="tooltip" style="display:none"></div>
        <div id="overlay" class="overlay" style="display:none"></div>
      </div>

      <div id="contentSearch" style="display:none">
        <div style="display:flex;gap:8px;align-items:center">
          <input id="searchInput" placeholder="Search user..." />
          <button id="searchBtn">Search</button>
        </div>
        <div style="margin-top:12px" id="searchResult"></div>
      </div>

      <div id="contentConnections" style="display:none">
        <div><strong>Your Connections</strong></div>
        <div id="connectionsList" class="friendsList"></div>
      </div>

    </div>
  </div>
</div>

<!-- Firebase + App -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
  import {
    getFirestore, collection, doc, setDoc, getDoc, getDocs, query, where, addDoc, updateDoc, orderBy, limit
  } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

  // ---------- config (your project) ----------
  const firebaseConfig = {
    apiKey: "AIzaSyDWJGM1oL-3i1CS8RsOCmgoJLKMe0aRCMA",
    authDomain: "relate-8fed6.firebaseapp.com",
    projectId: "relate-8fed6",
    storageBucket: "relate-8fed6.firebasestorage.app",
    messagingSenderId: "189997542155",
    appId: "1:189997542155:web:5a16a249d6b1daf8cad00e"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // ---------- utility: SHA-256 hashing for password ----------
  async function sha256(str){
    const enc = new TextEncoder();
    const buf = await crypto.subtle.digest('SHA-256', enc.encode(str));
    return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
  }

  // ---------- DOM refs ----------
  const loginName = document.getElementById('loginName');
  const loginPass = document.getElementById('loginPass');
  const loginClass = document.getElementById('loginClass');
  const btnEnter = document.getElementById('btnEnter');
  const btnLogout = document.getElementById('btnLogout');
  const who = document.getElementById('who');
  const usersList = document.getElementById('usersList');
  const suggestionsDiv = document.getElementById('suggestions');
  const reqBadge = document.getElementById('reqBadge');

  const tabRequests = document.getElementById('tabRequests');
  const tabMessages = document.getElementById('tabMessages');
  const tabMap = document.getElementById('tabMap');
  const tabSearch = document.getElementById('tabSearch');
  const tabConnections = document.getElementById('tabConnections');

  const contentRequests = document.getElementById('contentRequests');
  const contentMessages = document.getElementById('contentMessages');
  const contentMap = document.getElementById('contentMap');
  const contentSearch = document.getElementById('contentSearch');
  const contentConnections = document.getElementById('contentConnections');

  const requestsBox = document.getElementById('requestsBox');
  const quickPhrasesDiv = document.getElementById('quickPhrases');
  const chatArea = document.getElementById('chatArea');
  const mapSvg = document.getElementById('mapSvg');
  const tooltip = document.getElementById('tooltip');
  const overlay = document.getElementById('overlay');
  const searchInput = document.getElementById('searchInput');
  const searchBtn = document.getElementById('searchBtn');
  const searchResult = document.getElementById('searchResult');
  const connectionsList = document.getElementById('connectionsList');
  const btnRefresh = document.getElementById('btnRefresh');

  // populate classes
  for(let i=1;i<=12;i++){ const o=document.createElement('option');o.value=i;o.textContent=`Class ${i}`; loginClass.appendChild(o); }

  // quick phrases
  const canned = ['hi','bye','brb','ttyl','wsp','good','wow','ok','gtg'];
  canned.forEach(p=>{
    const b=document.createElement('button'); b.textContent=p; b.onclick = ()=> sendQuickPhrase(p); quickPhrasesDiv.appendChild(b);
  });

  // ---------- App state ----------
  // currentUser: { name, class }
  let currentUser = JSON.parse(localStorage.getItem('relate_current')) || null;

  // cached data
  let usersCache = []; // [{id, name, class, passHash}]
  let requestsCache = []; // firestore docs
  let relationshipsCache = []; // { id, userA, userB, typeA, typeB, lastChangedA, lastChangedB }
  let messagesCache = []; // not used for map but for chat
  let notificationsCache = [];

  // relation types and colors
  const RELATIONS = {
    'Friends': getComputedStyle(document.documentElement).getPropertyValue('--blue').trim() || '#70c6ff',
    'Close Friends': getComputedStyle(document.documentElement).getPropertyValue('--green').trim() || '#6ee07a',
    'Best Friends': getComputedStyle(document.documentElement).getPropertyValue('--yellow').trim() || '#ffd24d',
    'Crush': getComputedStyle(document.documentElement).getPropertyValue('--pink').trim() || '#ff90d0',
    'Hate': getComputedStyle(document.documentElement).getPropertyValue('--red').trim() || '#ff6b6b',
    'Classmate': getComputedStyle(document.documentElement).getPropertyValue('--whiteRel').trim() || '#ffffff'
  };

  // ---------- Helpers for Firestore reads/writes ----------
  async function loadAllUsers(){
    const snap = await getDocs(collection(db,'users'));
    usersCache = snap.docs.map(d => ({ id: d.id, ...d.data() }));
  }
  async function loadAllRequests(){
    const snap = await getDocs(collection(db,'requests'));
    requestsCache = snap.docs.map(d => ({ id: d.id, ...d.data() }));
  }
  async function loadAllRelationships(){
    const snap = await getDocs(collection(db,'relationships'));
    relationshipsCache = snap.docs.map(d => ({ id: d.id, ...d.data() }));
  }
  async function loadAllMessages(){
    const snap = await getDocs(collection(db,'messages'));
    messagesCache = snap.docs.map(d => ({ id: d.id, ...d.data() }));
  }
  async function loadAllNotifications(){
    const snap = await getDocs(collection(db,'notifications'));
    notificationsCache = snap.docs.map(d => ({ id: d.id, ...d.data() }));
  }

  // deterministic relationship document id
  function relDocId(a,b){ return [a.trim().toLowerCase(), b.trim().toLowerCase()].sort().join('__').replace(/\s+/g,'_'); }

  // create user doc (if not exist)
  async function createUserIfNotExist(name, klass, passwordHash){
    // find by name (case-insensitive)
    await loadAllUsers();
    const exists = usersCache.find(u => u.name.toLowerCase() === name.toLowerCase());
    if(!exists){
      const docRef = await addDoc(collection(db,'users'), { name, class: klass, passHash: passwordHash });
      await loadAllUsers();
      return docRef;
    } else {
      // if exists but missing passHash and we have passwordHash, set it
      if(passwordHash && !exists.passHash){
        await updateDoc(doc(db,'users', exists.id), { passHash: passwordHash });
        await loadAllUsers();
      }
      return exists;
    }
  }

  // find user doc by name
  async function findUserDocByName(name){
    await loadAllUsers();
    return usersCache.find(u => u.name.toLowerCase() === name.toLowerCase()) || null;
  }

  // ---------- Login flow (username+password quick auth) ----------
  btnEnter.addEventListener('click', async ()=>{
    const name = loginName.value.trim();
    const pass = loginPass.value;
    const klass = loginClass.value;
    if(!name || !pass || !klass) return alert('Enter name, password and class');

    const passHash = await sha256(pass);

    // check if user exists
    const existing = await findUserDocByName(name);
    if(existing){
      // validate password
      if(existing.passHash && existing.passHash !== passHash){
        return alert('Wrong password for this username.');
      }
      // logged in
      currentUser = { name: existing.name, class: existing.class || klass, uid: existing.id };
      localStorage.setItem('relate_current', JSON.stringify(currentUser));
      // if class changed, update
      if(existing.class !== klass){
        await updateDoc(doc(db,'users', existing.id), { class: klass });
      }
      await postLoginInit();
      alert('Welcome back, ' + existing.name);
    } else {
      // create new user
      const r = await addDoc(collection(db,'users'), { name, class: klass, passHash });
      currentUser = { name, class: klass, uid: r.id };
      localStorage.setItem('relate_current', JSON.stringify(currentUser));
      await postLoginInit();
      alert('Account created. Welcome ' + name);
    }
  });

  btnLogout.addEventListener('click', ()=>{
    localStorage.removeItem('relate_current');
    currentUser = null;
    window.location.reload();
  });

  async function postLoginInit(){
    who.textContent = `${currentUser.name} (Class ${currentUser.class})`;
    btnLogout.style.display = 'inline-block';
    document.getElementById('loginPanel').style.display = 'none';
    // load data
    await Promise.all([loadAllUsers(), loadAllRequests(), loadAllRelationships(), loadAllMessages(), loadAllNotifications()]);
    renderUsers();
    renderSuggestions();
    updateReqBadge();
    drawMap();
  }

  // auto-login if saved
  (async function init(){
    if(currentUser){
      await postLoginInit();
    } else {
      // show login panel
      document.getElementById('loginPanel').style.display = 'block';
    }
  })();

  // ---------- Rendering sidebar users ----------
  function renderUsers(){
    usersList.innerHTML = '';
    const others = usersCache.filter(u => u.name.toLowerCase() !== (currentUser?currentUser.name.toLowerCase():''));
    others.sort((a,b)=>a.name.localeCompare(b.name));
    others.forEach(u=>{
      const row = document.createElement('div'); row.className='userRow';
      const left = document.createElement('div');
      left.innerHTML = `<div style="font-weight:700">${u.name}</div><div class="small">Class ${u.class||'–'}</div>`;
      const right = document.createElement('div');
      // check request sent or connected
      const sent = requestsCache.some(r=>r.from.toLowerCase()=== (currentUser?currentUser.name.toLowerCase():'') && r.to.toLowerCase()===u.name.toLowerCase());
      const connected = relationshipsCache.some(r=> (r.userA.toLowerCase()===u.name.toLowerCase() && r.userB.toLowerCase()===currentUser.name.toLowerCase()) || (r.userB.toLowerCase()===u.name.toLowerCase() && r.userA.toLowerCase()===currentUser.name.toLowerCase()) );
      const btn = document.createElement('button');
      if(connected){ btn.textContent = 'Connected'; btn.disabled=true; }
      else if(sent){ btn.textContent='Sent ✓'; btn.disabled=true; }
      else { btn.textContent='+'; btn.disabled = !currentUser; }
      btn.onclick = async ()=>{
        if(!currentUser) return alert('Login first');
        // send request doc
        await addDoc(collection(db,'requests'), { from: currentUser.name, to: u.name, status: 'pending', time: Date.now() });
        await loadAllRequests();
        renderUsers(); updateReqBadge();
        alert(`✅ Request sent to ${u.name}`);
      };
      right.appendChild(btn);
      row.appendChild(left); row.appendChild(right);
      usersList.appendChild(row);
    });
  }

  // ---------- Suggestions (You might know) ----------
  function renderSuggestions(){
    suggestionsDiv.innerHTML = '';
    // compute mutual counts for each pair relative to currentUser
    if(!currentUser) return;
    // build adjacency via relationshipsCache where accepted connections exist (t.typeA==='accepted' not used — we treat connections as created on accept)
    // For simplicity, treat any relationship doc as connection (we accept requests create relationship doc)
    // We'll compute mutuals based on relationshipsCache where both parties are connected to someone in common
    const myConnections = relationshipsCache.filter(r => (r.userA.toLowerCase()===currentUser.name.toLowerCase() || r.userB.toLowerCase()===currentUser.name.toLowerCase())).map(r => (r.userA.toLowerCase()===currentUser.name.toLowerCase()? r.userB : r.userA));
    const suggestions = [];
    usersCache.forEach(u=>{
      if(u.name.toLowerCase()===currentUser.name.toLowerCase()) return;
      if(myConnections.includes(u.name)) return; // already connected
      // count mutuals: how many of myConnections are connected to u
      let mutual = 0;
      myConnections.forEach(m=>{
        const has = relationshipsCache.some(r => ((r.userA.toLowerCase()===m.toLowerCase() && r.userB.toLowerCase()===u.name.toLowerCase()) || (r.userB.toLowerCase()===m.toLowerCase() && r.userA.toLowerCase()===u.name.toLowerCase())));
        if(has) mutual++;
      });
      if(mutual >= 3) suggestions.push({ user:u, mutual });
    });
    // show suggestions
    suggestions.forEach(s=>{
      const d = document.createElement('div'); d.className='userRow';
      d.innerHTML = `<div><div style="font-weight:700">${s.user.name}</div><div class="small">Class ${s.user.class||'–'} • ${s.mutual} mutuals</div></div>`;
      const right = document.createElement('div');
      const addBtn = document.createElement('button'); addBtn.textContent='+';
      addBtn.onclick = async ()=> {
        // send request
        await addDoc(collection(db,'requests'), { from: currentUser.name, to: s.user.name, status:'pending', time: Date.now() });
        await loadAllRequests(); renderUsers(); updateReqBadge(); alert(`Request sent to ${s.user.name}`);
        renderSuggestions();
      };
      const xBtn = document.createElement('button'); xBtn.textContent='×'; xBtn.style.marginLeft='6px';
      xBtn.onclick = ()=> { d.style.display='none'; }; // dismissed until refresh
      right.appendChild(addBtn); right.appendChild(xBtn);
      d.appendChild(right);
      suggestionsDiv.appendChild(d);
    });
    if(suggestions.length===0) suggestionsDiv.innerHTML = '<div class="smallMuted">No suggestions for now.</div>';
  }

  // ---------- Requests UI ----------
  tabRequests.addEventListener('click', ()=> { showTab('requests'); renderRequests(); });
  async function renderRequests(){
    await loadAllRequests();
    requestsBox.innerHTML = '<strong>Incoming Requests</strong>';
    if(!currentUser) { requestsBox.innerHTML += '<div class="smallMuted">Login to see requests</div>'; return; }
    const incoming = requestsCache.filter(r=> r.to.toLowerCase() === currentUser.name.toLowerCase() && r.status === 'pending');
    if(incoming.length===0) requestsBox.innerHTML += '<div class="smallMuted">No pending requests</div>';
    incoming.forEach(r=>{
      const div = document.createElement('div'); div.className='requestItem';
      div.innerHTML = `<div><div style="font-weight:700">${r.from}</div><div class="small">sent ${(new Date(r.time)).toLocaleString()}</div></div>`;
      const right = document.createElement('div');
      const acc = document.createElement('button'); acc.textContent='Accept';
      acc.onclick = async ()=>{
        // Accept: create relationship doc (deterministic id)
        const id = relDocId(r.from, r.to);
        // create or update relationships doc
        const ref = doc(db,'relationships', id);
        const snap = await getDoc(ref);
        if(!snap.exists()){
          await setDoc(ref, { userA: r.from, userB: r.to, typeA: null, typeB: null, lastChangedA: null, lastChangedB: null });
        }
        // mark request removed (update status)
        await updateDoc(doc(db,'requests', r.id), { status: 'accepted' });
        // send notification to requester
        await addDoc(collection(db,'notifications'), { to: r.from, text: `${r.to} accepted your connection.`, time: Date.now(), seen: false });
        await loadAllRelationships(); await loadAllRequests(); renderUsers(); renderRequests(); updateReqBadge(); drawMap(); alert('Connection accepted');
      };
      const dec = document.createElement('button'); dec.textContent='Decline'; dec.style.marginLeft='6px';
      dec.onclick = async ()=>{
        await updateDoc(doc(db,'requests', r.id), { status: 'rejected' });
        await loadAllRequests(); renderUsers(); renderRequests(); updateReqBadge(); alert('Request declined');
      };
      right.appendChild(acc); right.appendChild(dec);
      div.appendChild(right); requestsBox.appendChild(div);
    });
  }

  // request badge count
  async function updateReqBadge(){
    await loadAllRequests();
    const count = requestsCache.filter(r => r.to.toLowerCase() === (currentUser?currentUser.name.toLowerCase():'') && r.status === 'pending').length;
    reqBadge.textContent = String(count);
  }

  // ---------- Map & Relationships ----------
  tabMap.addEventListener('click', ()=> { showTab('map'); drawMap(); });

  async function drawMap(){
    // reload caches to reflect latest
    await Promise.all([loadAllUsers(), loadAllRelationships(), loadAllRequests()]);
    mapSvg.innerHTML = '';
    tooltip.style.display='none'; overlay.style.display='none';
    if(!currentUser) return;

    // center
    const centerX = 500, centerY = 350;
    const centerNode = { name: currentUser.name, x:centerX, y:centerY, r:30, isCenter:true };
    // direct connections: relationships where either userA or userB equals currentUser
    const direct = [];
    relationshipsCache.forEach(r => {
      if(r.userA && r.userB){
        if(r.userA.toLowerCase() === currentUser.name.toLowerCase()) direct.push(r.userB);
        else if(r.userB.toLowerCase() === currentUser.name.toLowerCase()) direct.push(r.userA);
      }
    });
    const uniqueDirect = Array.from(new Set(direct));
    // create friend nodes around circle
    const nodes = [centerNode];
    const count = uniqueDirect.length;
    const radius = Math.min(280, 90 + count*30);
    uniqueDirect.forEach((nm,i)=>{
      const angle = (i / Math.max(1,count)) * Math.PI * 2 - Math.PI/2;
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      nodes.push({ name: nm, x, y, r:20 });
    });

    // helper find node
    const findNode = name => nodes.find(n => n.name.toLowerCase() === name.toLowerCase());

    // draw relationship lines for any pair existing among nodes (including connections between friend nodes)
    relationshipsCache.forEach(r => {
      if(!r.userA || !r.userB) return;
      const nA = findNode(r.userA), nB = findNode(r.userB);
      if(!nA || !nB) return; // skip relationships outside visual scope
      // determine display
      const tA = r.typeA || null, tB = r.typeB || null;
      let draw=false, dashed=false, color=null;
      if(tA && tB){
        draw = true;
        if(tA === tB){ color = RELATIONS[tA] || '#9b9b9b'; dashed=false; }
        else { color = '#9b9b9b'; dashed=false; } // mismatch
      } else if(tA || tB){
        draw = true; dashed = true; color = '#9b9b9b';
      } else {
        draw = false; // no line until someone picks
      }
      if(!draw) return;
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', nA.x); line.setAttribute('y1', nA.y);
      line.setAttribute('x2', nB.x); line.setAttribute('y2', nB.y);
      line.setAttribute('stroke-width', 3);
      if(dashed){ line.setAttribute('stroke-dasharray','8 6'); line.setAttribute('stroke', color); }
      else { line.setAttribute('stroke', color); }
      mapSvg.appendChild(line);
    });

    // draw nodes
    nodes.forEach(node=>{
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('transform', `translate(${node.x},${node.y})`);
      g.setAttribute('data-name', node.name);
      // circle
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('r', node.r);
      circle.setAttribute('fill', node.isCenter ? '#cfa0ff' : '#70c6ff');
      circle.setAttribute('stroke','#fff'); circle.setAttribute('stroke-width', node.isCenter?2:1);
      circle.style.cursor = 'pointer';
      g.appendChild(circle);
      // label
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('y', node.isCenter ? 6 : 4);
      text.setAttribute('text-anchor','middle');
      text.setAttribute('font-size', node.isCenter?14:11);
      text.setAttribute('fill','#111');
      text.textContent = node.name;
      g.appendChild(text);

      // hover
      g.addEventListener('mouseenter', async (ev)=>{
        const nm = node.name;
        const user = usersCache.find(u => u.name.toLowerCase()===nm.toLowerCase()) || {};
        const myRel = getMyRelationTo(nm);
        tooltip.style.display='block';
        tooltip.innerHTML = `<strong>${nm}</strong> • Class ${user.class || '–'}<br><span class="small">${myRel?('You set: '+myRel):'No relation set'}</span>`;
        positionTooltip(ev);
      });
      g.addEventListener('mousemove', positionTooltip);
      g.addEventListener('mouseleave', ()=> tooltip.style.display='none');

      // click -> profile overlay
      g.addEventListener('click', ()=> openProfile(node.name));
      mapSvg.appendChild(g);
    });

    function positionTooltip(ev){
      const rect = mapSvg.getBoundingClientRect();
      tooltip.style.left = (ev.clientX - rect.left) + 'px';
      tooltip.style.top = (ev.clientY - rect.top - 12) + 'px';
    }
  }

  // ---------- Profile overlay ----------
  function openProfile(name){
    overlay.style.display = 'block';
    overlay.innerHTML = '';
    const user = usersCache.find(u => u.name.toLowerCase()===name.toLowerCase()) || { class:'–' };
    const title = document.createElement('div'); title.innerHTML = `<h3 style="margin:0">${name}</h3>`;
    overlay.appendChild(title);
    const info = document.createElement('div'); info.className='smallMuted'; info.textContent = `Class ${user.class || '–'}`; overlay.appendChild(info);
    // connections count
    const count = relationshipsCache.filter(r => (r.userA && r.userB) && (r.userA.toLowerCase()===name.toLowerCase() || r.userB.toLowerCase()===name.toLowerCase())).length;
    const cc = document.createElement('div'); cc.className='smallMuted'; cc.style.marginTop='8px'; cc.textContent = `${count} connection${count!==1?'s':''}`; overlay.appendChild(cc);

    // show relation setter if not self and connection exists
    if(currentUser && currentUser.name.toLowerCase() !== name.toLowerCase()){
      // ensure connection exists
      const rid = relDocId(currentUser.name, name);
      const relDoc = relationshipsCache.find(r => r.id === rid);
      const isConnected = !!relDoc;
      if(isConnected){
        const relWrap = document.createElement('div'); relWrap.style.marginTop='12px';
        const label = document.createElement('div'); label.textContent = 'Set your relation to this person (change once / 7 days)';
        relWrap.appendChild(label);
        const sel = document.createElement('select'); sel.className='relSelect';
        sel.innerHTML = `<option value="">Choose relation</option>`;
        Object.keys(RELATIONS).forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent=k; sel.appendChild(o); });
        // preselect if currentUser already set
        const existing = getMyRelationTo(name);
        if(existing) sel.value = existing;
        relWrap.appendChild(sel);
        const saveBtn = document.createElement('button'); saveBtn.textContent='Save relation'; saveBtn.style.marginTop='8px';
        saveBtn.onclick = async ()=>{
          const chosen = sel.value;
          if(!chosen) return alert('Pick a relation');
          // enforce 7-day cooldown
          const conn = relationshipsCache.find(r=>r.id===rid);
          const now = Date.now();
          if(conn){
            const isA = conn.userA.toLowerCase() === currentUser.name.toLowerCase();
            const last = isA ? conn.lastChangedA : conn.lastChangedB;
            if(last && (now - last < 7*24*3600*1000)) return alert('You can change relation only once per 7 days.');
          }
          // update doc: set typeA or typeB accordingly
          const ref = doc(db,'relationships',rid);
          const snapshot = await getDoc(ref);
          if(!snapshot.exists()){
            // shouldn't happen: create base doc
            await setDoc(ref, { userA: currentUser.name, userB: name, typeA: null, typeB: null, lastChangedA: null, lastChangedB: null });
          }
          const data = (await getDoc(ref)).data();
          // decide slot
          if(data.userA.toLowerCase() === currentUser.name.toLowerCase()){
            await updateDoc(ref, { typeA: chosen, lastChangedA: Date.now() });
          } else if(data.userB.toLowerCase() === currentUser.name.toLowerCase()){
            await updateDoc(ref, { typeB: chosen, lastChangedB: Date.now() });
          } else {
            // fallback, set A
            await updateDoc(ref, { typeA: chosen, lastChangedA: Date.now() });
          }
          // add notification to other user prompting them to set their relation
          await addDoc(collection(db,'notifications'), { to: name, text: `${currentUser.name} updated your connection status — pick your view.`, time: Date.now(), seen:false });
          // refresh caches & UI
          await loadAllRelationships(); drawMap(); updateReqBadge(); alert('Relation saved. Other user has been notified.');
          overlay.style.display='none';
        };
        relWrap.appendChild(saveBtn);
        overlay.appendChild(relWrap);
      } else {
        const notConn = document.createElement('div'); notConn.className='smallMuted'; notConn.style.marginTop='12px'; notConn.textContent = 'You are not connected with this user.';
        overlay.appendChild(notConn);
      }
    }

    // Chat panel if connected
    if(currentUser && areConnected(currentUser.name, name)){
      const chatTitle = document.createElement('div'); chatTitle.style.marginTop='12px'; chatTitle.innerHTML = `<strong>Chat with ${name}</strong>`;
      overlay.appendChild(chatTitle);
      const chatWrap = document.createElement('div'); chatWrap.style.marginTop='8px';
      const messagesDiv = document.createElement('div'); messagesDiv.style.maxHeight='160px'; messagesDiv.style.overflow='auto'; messagesDiv.style.background='#fff'; messagesDiv.style.color='#111'; messagesDiv.style.padding='8px'; messagesDiv.style.borderRadius='8px';
      chatWrap.appendChild(messagesDiv);
      const inputRow = document.createElement('div'); inputRow.style.display='flex'; inputRow.style.gap='6px'; inputRow.style.marginTop='8px';
      const input = document.createElement('input'); input.placeholder='Type a message';
      const send = document.createElement('button'); send.textContent='Send';
      send.onclick = async ()=>{
        const txt = input.value.trim(); if(!txt) return;
        const chatId = messagesChatId(currentUser.name, name);
        await addDoc(collection(db,'messages'), { chatId, from: currentUser.name, to: name, text: txt, time: Date.now() });
        input.value='';
        await loadAllMessages(); renderMessages(messagesDiv, chatId);
      };
      inputRow.appendChild(input); inputRow.appendChild(send);
      overlay.appendChild(chatWrap); overlay.appendChild(inputRow);
      // render existing
      (async ()=> { await loadAllMessages(); renderMessages(messagesDiv, messagesChatId(currentUser.name, name)); })();
    }

    const close = document.createElement('button'); close.textContent='Close'; close.style.marginTop='12px'; close.onclick = ()=> overlay.style.display='none';
    overlay.appendChild(close);
  }

  function messagesChatId(a,b){ return [a.trim().toLowerCase(), b.trim().toLowerCase()].sort().join('__'); }
  function renderMessages(container, chatId){
    container.innerHTML = '';
    const msgs = messagesCache.filter(m => m.chatId === chatId).sort((a,b)=>a.time-b.time);
    msgs.forEach(m=>{
      const d = document.createElement('div'); d.style.margin='6px 0'; d.textContent = `${m.from}: ${m.text}`;
      container.appendChild(d);
    });
  }

  // ---------- Connections helpers ----------
  function areConnected(a,b){
    const id = relDocId(a,b);
    return relationshipsCache.some(r => r.id === id);
  }

  function getMyRelationTo(other){
    if(!currentUser) return null;
    const id = relDocId(currentUser.name, other);
    const docObj = relationshipsCache.find(r => r.id === id);
    if(!docObj) return null;
    if(docObj.userA.toLowerCase() === currentUser.name.toLowerCase()) return docObj.typeA || null;
    if(docObj.userB.toLowerCase() === currentUser.name.toLowerCase()) return docObj.typeB || null;
    return null;
  }

  // get relation to current user by other (private: we do not reveal other user's pick)
  function getRelationOtherToCurrent(other){
    const id = relDocId(currentUser.name, other);
    const docObj = relationshipsCache.find(r => r.id === id);
    if(!docObj) return null;
    if(docObj.userA.toLowerCase() === other.toLowerCase()) return docObj.typeA || null;
    if(docObj.userB.toLowerCase() === other.toLowerCase()) return docObj.typeB || null;
    return null;
  }

  // ---------- Search ----------
  tabSearch.addEventListener('click', ()=> showTab('search'));
  searchBtn.addEventListener('click', async ()=>{
    const q = searchInput.value.trim();
    searchResult.innerHTML = '';
    if(!q) return (searchResult.textContent = 'Enter a name to search.');
    await loadAllUsers();
    const found = usersCache.find(u => u.name.toLowerCase() === q.toLowerCase());
    if(!found) return (searchResult.textContent = 'User not found.');
    const div = document.createElement('div');
    div.innerHTML = `<div style="font-weight:700">${found.name}</div><div class="small">Class ${found.class||'–'}</div>`;
    const btn = document.createElement('button');
    // check existing request/connection
    const sent = requestsCache.some(r=>r.from.toLowerCase()===currentUser.name.toLowerCase() && r.to.toLowerCase()===found.name.toLowerCase());
    const connected = relationshipsCache.some(r=> (r.userA.toLowerCase()===found.name.toLowerCase() && r.userB.toLowerCase()===currentUser.name.toLowerCase()) || (r.userB.toLowerCase()===found.name.toLowerCase() && r.userA.toLowerCase()===currentUser.name.toLowerCase()) );
    if(connected){ btn.textContent='Connected'; btn.disabled=true; } else if(sent){ btn.textContent='Sent ✓'; btn.disabled=true; } else { btn.textContent='Send Request'; }
    btn.onclick = async ()=>{
      await addDoc(collection(db,'requests'), { from: currentUser.name, to: found.name, status:'pending', time: Date.now() });
      await loadAllRequests(); renderUsers(); updateReqBadge(); alert('Request sent');
    };
    div.appendChild(btn); searchResult.appendChild(div);
  });

  // ---------- Connections tab rendering ----------
  tabConnections.addEventListener('click', ()=> { showTab('connections'); renderConnections(); });
  async function renderConnections(){
    await loadAllRelationships();
    connectionsList.innerHTML = '';
    if(!currentUser) return;
    const myConns = relationshipsCache.filter(r => r.userA.toLowerCase()===currentUser.name.toLowerCase() || r.userB.toLowerCase()===currentUser.name.toLowerCase());
    if(myConns.length===0) connectionsList.innerHTML = '<div class="smallMuted">No connections yet.</div>';
    myConns.forEach(c=>{
      const other = c.userA.toLowerCase()===currentUser.name.toLowerCase() ? c.userB : c.userA;
      const div = document.createElement('div'); div.className='friendItem';
      div.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div>${other}</div><div><button onclick="openProfileClient('${other.replace(/'/g,"\\'")}')">Profile</button></div></div>`;
      connectionsList.appendChild(div);
    });
  }

  // helper to call openProfile from inline onclick
  window.openProfileClient = function(name){ openProfile(name); };

  // ---------- Messages tab ----------
  tabMessages.addEventListener('click', ()=> { showTab('messages'); renderMessagesTab(); });
  async function renderMessagesTab(){
    await loadAllMessages();
    chatArea.innerHTML = '';
    if(!currentUser) return chatArea.innerHTML = '<div class="smallMuted">Login to chat with connections.</div>';
    // list connections with latest message preview
    const myConns = relationshipsCache.filter(r => r.userA.toLowerCase()===currentUser.name.toLowerCase() || r.userB.toLowerCase()===currentUser.name.toLowerCase());
    myConns.forEach(c=>{
      const other = c.userA.toLowerCase()===currentUser.name.toLowerCase() ? c.userB : c.userA;
      const chatId = messagesChatId(currentUser.name, other);
      const msgs = messagesCache.filter(m => m.chatId === chatId).sort((a,b)=>b.time - a.time);
      const last = msgs[0];
      const div = document.createElement('div'); div.className='friendItem';
      div.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div><strong>${other}</strong><div class="small">${ last ? (last.from + ': ' + last.text) : 'No messages yet' }</div></div><div><button onclick="openChatClient('${other.replace(/'/g,"\\'")}')">Open</button></div></div>`;
      chatArea.appendChild(div);
    });
    if(myConns.length===0) chatArea.innerHTML = '<div class="smallMuted">No connections to message.</div>';
  }

  window.openChatClient = function(name){ openChat(name); };

  async function openChat(name){
    // show overlay with chat for this friend
    overlay.style.display='block'; overlay.innerHTML='';
    const title = document.createElement('div'); title.innerHTML = `<h3 style="margin:0">Chat with ${name}</h3>`; overlay.appendChild(title);
    const messagesDiv = document.createElement('div'); messagesDiv.style.maxHeight='200px'; messagesDiv.style.overflow='auto'; messagesDiv.style.background='#fff'; messagesDiv.style.color='#111'; messagesDiv.style.padding='8px'; messagesDiv.style.borderRadius='8px'; messagesDiv.style.marginTop='8px';
    overlay.appendChild(messagesDiv);
    const inp = document.createElement('input'); inp.placeholder='Type a message'; inp.style.marginTop='8px';
    const send = document.createElement('button'); send.textContent='Send'; send.style.marginLeft='6px';
    send.onclick = async ()=>{
      const t = inp.value.trim(); if(!t) return;
      await addDoc(collection(db,'messages'), { chatId: messagesChatId(currentUser.name, name), from: currentUser.name, to: name, text: t, time: Date.now() });
      inp.value=''; await loadAllMessages(); renderMessages(messagesDiv, messagesChatId(currentUser.name, name));
    };
    overlay.appendChild(inp); overlay.appendChild(send);
    await loadAllMessages(); renderMessages(messagesDiv, messagesChatId(currentUser.name, name));
    const close = document.createElement('button'); close.textContent='Close'; close.style.marginTop='10px'; close.onclick = ()=> overlay.style.display='none'; overlay.appendChild(close);
  }

  function renderMessages(container, chatId){ container.innerHTML = ''; const msgs = messagesCache.filter(m=>m.chatId===chatId).sort((a,b)=>a.time-b.time); msgs.forEach(m=>{ const d = document.createElement('div'); d.style.margin='6px 0'; d.style.padding='6px'; d.style.borderRadius='6px'; d.style.background = m.from===currentUser.name?'#dfeaff':'#ffeef2'; d.textContent = `${m.from}: ${m.text}`; container.appendChild(d); }); }

  function sendQuickPhrase(p){ // if overlay open and chat present
    // find current chat friend if overlay has h3 "Chat with NAME"
    const h3 = overlay.querySelector('h3');
    if(!h3) return alert('Open a chat first (click a connection -> Chat).');
    const name = h3.textContent.replace('Chat with ','').trim();
    openChat(name); // ensure chat is loaded - but send after
    (async ()=>{ await addDoc(collection(db,'messages'), { chatId: messagesChatId(currentUser.name, name), from: currentUser.name, to: name, text: p, time: Date.now() }); await loadAllMessages(); })();
  }

  // ---------- Notifications small UI (reqBadge used) ----------
  // showTab helper
  function showTab(tab){
    [contentRequests, contentMessages, contentMap, contentSearch, contentConnections].forEach(c=>c.style.display='none');
    [tabRequests, tabMessages, tabMap, tabSearch, tabConnections].forEach(b=>b.classList.remove('activeTab'));
    if(tab==='requests'){ contentRequests.style.display='block'; tabRequests.classList.add('activeTab'); renderRequests(); }
    if(tab==='messages'){ contentMessages.style.display='block'; tabMessages.classList.add('activeTab'); renderMessagesTab(); }
    if(tab==='map'){ contentMap.style.display='block'; tabMap.classList.add('activeTab'); drawMap(); }
    if(tab==='search'){ contentSearch.style.display='block'; tabSearch.classList.add('activeTab'); }
    if(tab==='connections'){ contentConnections.style.display='block'; tabConnections.classList.add('activeTab'); renderConnections(); }
  }

  // ---------- helpers ----------
  function relDocId(a,b){ return [a.trim().toLowerCase(), b.trim().toLowerCase()].sort().join('__').replace(/\s+/g,'_'); }
  function getMyRelationTo(other){
    if(!currentUser) return null;
    const id = relDocId(currentUser.name, other);
    const docObj = relationshipsCache.find(r => r.id === id);
    if(!docObj) return null;
    if(docObj.userA.toLowerCase() === currentUser.name.toLowerCase()) return docObj.typeA || null;
    if(docObj.userB.toLowerCase() === currentUser.name.toLowerCase()) return docObj.typeB || null;
    return null;
  }

  function messagesChatId(a,b){ return [a.trim().toLowerCase(), b.trim().toLowerCase()].sort().join('__'); }

  // ---------- Refresh button ----------
  btnRefresh.addEventListener('click', async ()=>{ await Promise.all([loadAllUsers(), loadAllRequests(), loadAllRelationships(), loadAllMessages(), loadAllNotifications()]); renderUsers(); renderSuggestions(); updateReqBadge(); drawMap(); alert('Refreshed'); });

  // initial tab
  showTab('map');

  // small helper to open profile via global (for inline usage)
  window.openProfileClient = (n) => openProfile(n);

  // End of module
</script>
</body>
</html>
